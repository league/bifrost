
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>3. Create a Pipeline &#8212; bifrost 0.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
    <script src="static/jquery.js"></script>
    <script src="static/underscore.js"></script>
    <script src="static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Your first blocks" href="your-first-blocks.html" />
    <link rel="prev" title="2. Getting started guide" href="Getting-started-guide.html" />
   
  <link rel="stylesheet" href="static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="create-a-pipeline">
<h1><span class="section-number">3. </span>Create a Pipeline<a class="headerlink" href="#create-a-pipeline" title="Permalink to this headline">¶</a></h1>
<p>In this tutorial, we will create a simple
pipeline and execute it. Later on, we’ll create
our own version of a block and use it
in the pipeline. All of the code can be found
in one block at the bottom of this page.</p>
<p>With Bifrost, there is one main module you will
be calling as a user: <code class="docutils literal notranslate"><span class="pre">bifrost.pipeline</span></code>. This
handles all the behind-the-scenes pipeline construction,
giving you a high-level view at arranging a series of
blocks.</p>
<p>We would like to construct the following pipeline,
which will serve to calculate the beats per minute
of a song. As we will soon see, some intermediate
operations will be required to get the bpm, and
we can then write our own block.</p>
<ol class="arabic simple">
<li><p>Read in a <code class="docutils literal notranslate"><span class="pre">.wav</span></code> file to a ring buffer.</p></li>
<li><p>Channelize it with a GPU FFT.</p></li>
<li><p>Write it back to disk as a filterbank file.</p></li>
</ol>
<section id="blocks-in-this-example">
<h2><span class="section-number">3.1. </span>Blocks in this Example<a class="headerlink" href="#blocks-in-this-example" title="Permalink to this headline">¶</a></h2>
<p>This setup will require bifrost blocks which:</p>
<ol class="arabic simple">
<li><p>Read in the <code class="docutils literal notranslate"><span class="pre">.wav</span></code> file.</p></li>
<li><p>Copy the raw data to the GPU.</p></li>
<li><p>Split the time axis into chunks which we can FFT over.</p></li>
<li><p>FFT this new axis.</p></li>
<li><p>Take the modulus squared of these FFTs.</p></li>
<li><p>Transpose this data into a format compatible with the sigproc writer.</p></li>
<li><p>Copy the data back to the CPU.</p></li>
<li><p>Convert the data into integer data types.</p></li>
<li><p>Write this data to a filterbank file.</p></li>
</ol>
<p>This file could then be used to do things like calculating
the beats per minute of the song at different points of time, or
could be used to just view the frequency components of the song with time.</p>
<p>First, ensure you have a working Bifrost installation. You should
also have some CUDA-compatible GPUs to run this example.</p>
</section>
<section id="code-walkthrough">
<h2><span class="section-number">3.2. </span>Code Walkthrough<a class="headerlink" href="#code-walkthrough" title="Permalink to this headline">¶</a></h2>
<p>Now, let’s create the pipeline.</p>
<p>The first thing to do is to actually load in Bifrost. Load in the base
library as <code class="docutils literal notranslate"><span class="pre">bf</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bifrost</span> <span class="k">as</span> <span class="nn">bf</span>
</pre></div>
</div>
<p>Next, let’s load in some function libraries. We want <code class="docutils literal notranslate"><span class="pre">blocks</span></code>,
which is the block module in Bifrost, which is a collection of
previously-written blocks for various functionality,and
<code class="docutils literal notranslate"><span class="pre">views</span></code>, which is a library for manipulations of ring headers.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bifrost.blocks</span> <span class="k">as</span> <span class="nn">blocks</span>
<span class="kn">import</span> <span class="nn">bifrost.views</span> <span class="k">as</span> <span class="nn">views</span>
</pre></div>
</div>
<p>Now, let’s create our data “source,” our source block. This is the
block that feeds our pipeline with data. In this example,
we work with a <code class="docutils literal notranslate"><span class="pre">.wav</span></code> file. I assume that you have own some
sort of audio file and can convert it, using, e.g.,
<a class="reference external" href="http://audio.online-convert.com/convert-to-wav">online-convert</a>.</p>
<p>Now, I want to load this into Bifrost. The syntax for
this instance is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">raw_data</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">read_wav</span><span class="p">([</span><span class="s1">&#39;heyjude.wav&#39;</span><span class="p">],</span> <span class="n">gulp_nframe</span><span class="o">=</span><span class="mi">4096</span><span class="p">)</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">['heyjude.wav']</span></code> is a list of <code class="docutils literal notranslate"><span class="pre">.wav</span></code> files, which is in this
case, a sample of <cite>Hey Jude</cite>. <code class="docutils literal notranslate"><span class="pre">gulp_nframe</span></code> is an argument passed
to this block which tells it how many <cite>frames</cite> of data to <cite>gulp</cite> at once.</p>
<p>Some terminology:</p>
<ul class="simple">
<li><p><cite>frame</cite>: One chunk of data. In this case, it is a single sample of the
audio file. By setting <code class="docutils literal notranslate"><span class="pre">gulp_nframe=4096</span></code>, we tell the block to read
in 4096 samples at a time, and put these into the ring buffer at once.</p></li>
<li><p><cite>gulp</cite>: One read or write of the ring buffer. Imagine the block
taking a gulp of data. Then <code class="docutils literal notranslate"><span class="pre">gulp_nframe</span></code> is how many frames are
in that gulp.</p></li>
</ul>
<p>Now, <code class="docutils literal notranslate"><span class="pre">raw_data</span></code> is now a reference to a <code class="docutils literal notranslate"><span class="pre">block</span></code> object, which implicitly
points at the <cite>ring buffer</cite> which will hold the raw <code class="docutils literal notranslate"><span class="pre">.wav</span></code> data.</p>
<p>Next, we want to put this data onto the GPU. Bifrost makes this simple.
Insert a copy block as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gpu_raw_data</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this line we are telling Bifrost to create a new block, a <code class="docutils literal notranslate"><span class="pre">copy</span></code> block,
and set its input to be the <code class="docutils literal notranslate"><span class="pre">raw_data</span></code> variable which is the source block
for our audio file. Then, by setting <code class="docutils literal notranslate"><span class="pre">space='cuda'</span></code>, we tell Bifrost
to create a ring in GPU memory, and copy all of the contents of <code class="docutils literal notranslate"><span class="pre">raw_data</span></code>
into this new ring. With this GPU ring, we can connect more blocks and
do GPU processing.</p>
<p>Now, since we only want to do a Fourier transform at different parts of the
song, not the entirety of the song, we want to chunk up this audio file
into segments over which we can Fourier transform. This lets us get a
frequency view at various points of the song. Since our data comes
as one long time stream, we want to break it up into parts. Bifrost lets
you do this without extra processing. You simply manipulate the <cite>header</cite>
of the ring, which stores all of the descriptions for the ring. These
manipulations are accomplished with <code class="docutils literal notranslate"><span class="pre">views</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">chunked_data</span> <span class="o">=</span> <span class="n">views</span><span class="o">.</span><span class="n">split_axis</span><span class="p">(</span><span class="n">gpu_raw_data</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;fine_time&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>What have we done here? We took <code class="docutils literal notranslate"><span class="pre">gpu_raw_data</span></code>, which is a block on the GPU,
and which implicitly points to its output ring buffer which sits on the GPU,
and put it into the <code class="docutils literal notranslate"><span class="pre">split_axis</span></code> view. We said take the <code class="docutils literal notranslate"><span class="pre">'time'</span></code> axis
of this ring, and break it up into <code class="docutils literal notranslate"><span class="pre">256</span></code>-size chunks. Create a new
axis for this data, and call that axis <code class="docutils literal notranslate"><span class="pre">'fine_time'</span></code>.</p>
<p>Note that <cite>views</cite> are special in that they do not actually modify the data.
They just modify the metadata, which lets blocks interpret the data
differently.</p>
<p>Now, let’s actually do the processing. We want to do an FFT along this
256-size axis, and we want to do it on the GPU. Bifrost knows which
ring is on the GPU and CPU, so this is implicitly passed to the FFT block:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fft_output</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">chunked_data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;fine_time&#39;</span><span class="p">,</span> <span class="n">axis_labels</span><span class="o">=</span><span class="s1">&#39;freq&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>So, in this line, we create a new block, an <cite>FFT</cite> block, and send in
the chunked data. We tell the FFT block to perform the Fourier transform
along the <code class="docutils literal notranslate"><span class="pre">'fine_time'</span></code> axis, which is the one of 256-size chunks,
and then after Fourier transforming, to name the output axis <code class="docutils literal notranslate"><span class="pre">'freq'</span></code>.</p>
<p>The Bifrost FFT block wraps <code class="docutils literal notranslate"><span class="pre">cuFFT</span></code>, the CUDA FFT package, which is
heavily optimized. Inside the block, <code class="docutils literal notranslate"><span class="pre">bifrost.ndarray</span></code>’s are being
created from the output ring of <code class="docutils literal notranslate"><span class="pre">chunked_data</span></code>, and this is being
passed with <code class="docutils literal notranslate"><span class="pre">ctypes</span></code> into a C++ function.</p>
<p>Next, we want to take the square of these FFTs. In Bifrost,
this can be done with the <code class="docutils literal notranslate"><span class="pre">detect</span></code> block:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">squared</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="n">fft_output</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;scalar&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This block takes in the output of the FFT (we are still on the GPU!),
squares each element (the <code class="docutils literal notranslate"><span class="pre">'scalar'</span></code> mode), and then puts this in a
new ring, implicitly stored in the <code class="docutils literal notranslate"><span class="pre">squared</span></code> block object.</p>
<p>Now, after carefully reading the documentation for the <code class="docutils literal notranslate"><span class="pre">transpose</span></code> block,
we decide that we want to arrange the axes such that it goes in as
<code class="docutils literal notranslate"><span class="pre">['time',</span> <span class="pre">'pol',</span> <span class="pre">'freq']</span></code>. To do this, we need to transpose it.
Bifrost has the <code class="docutils literal notranslate"><span class="pre">transpose</span></code> block to do this. We simply type the
desired output axis layout as the only argument, and it is all performed
on the GPU for us:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">transposed</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">squared</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;pol&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>This transposes the axes for us. Now we can ship it into sigproc writer.
But first, we have to offload from the GPU:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">host_transposed</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">transposed</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s1">&#39;cuda_host&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, convert to an 8-bit integer data type for storage, with the
quantize block (<code class="docutils literal notranslate"><span class="pre">'i8'</span></code> means an <code class="docutils literal notranslate"><span class="pre">8</span></code>-bit <code class="docutils literal notranslate"><span class="pre">i</span></code> nteger).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">quantized</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">host_transposed</span><span class="p">,</span> <span class="s1">&#39;i8&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we pass the data stream into a <cite>sink</cite> block, which ends
the pipeline and stores the data in a filterbank file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">blocks</span><span class="o">.</span><span class="n">write_sigproc</span><span class="p">(</span><span class="n">quantized</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, the filename will be determined from
the header information, which contains the name of the original
<code class="docutils literal notranslate"><span class="pre">.wav</span></code> file. The output file is of type <code class="docutils literal notranslate"><span class="pre">.fil</span></code>, and
is the <cite>channelized</cite> version of the original music file. It
is the frequency decomposition of the audio.</p>
<p>So, what have we done? We:</p>
<ol class="arabic simple">
<li><p>Read in the <code class="docutils literal notranslate"><span class="pre">.wav</span></code> file.</p></li>
<li><p>Copied the raw data to the GPU.</p></li>
<li><p>Split the time axis into chunks which we could FFT over.</p></li>
<li><p>FFT’d along this new axis.</p></li>
<li><p>Took the modulus squared of these FFTs.</p></li>
<li><p>Transposed this data into a format compatible with the sigproc writer.</p></li>
<li><p>Copied the data back to the CPU.</p></li>
<li><p>Converted the data into integer data types.</p></li>
<li><p>Wrote this data to a filterbank file.</p></li>
</ol>
</section>
<section id="all-the-code">
<h2><span class="section-number">3.3. </span>All the Code<a class="headerlink" href="#all-the-code" title="Permalink to this headline">¶</a></h2>
<p>For ease of reference, here is all the code at once:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bifrost</span> <span class="k">as</span> <span class="nn">bf</span>
<span class="kn">import</span> <span class="nn">bifrost.blocks</span> <span class="k">as</span> <span class="nn">blocks</span>
<span class="kn">import</span> <span class="nn">bifrost.views</span> <span class="k">as</span> <span class="nn">views</span>

<span class="n">raw_data</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">read_wav</span><span class="p">([</span><span class="s1">&#39;heyjude.wav&#39;</span><span class="p">],</span> <span class="n">gulp_nframe</span><span class="o">=</span><span class="mi">4096</span><span class="p">)</span>
<span class="n">gpu_raw_data</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">chunked_data</span> <span class="o">=</span> <span class="n">views</span><span class="o">.</span><span class="n">split_axis</span><span class="p">(</span><span class="n">gpu_raw_data</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;fine_time&#39;</span><span class="p">)</span>
<span class="n">fft_output</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">chunked_data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;fine_time&#39;</span><span class="p">,</span> <span class="n">axis_labels</span><span class="o">=</span><span class="s1">&#39;freq&#39;</span><span class="p">)</span>
<span class="n">squared</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="n">fft_output</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;scalar&#39;</span><span class="p">)</span>
<span class="n">transposed</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">squared</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;pol&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">])</span>
<span class="n">host_transposed</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">transposed</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s1">&#39;cuda_host&#39;</span><span class="p">)</span>
<span class="n">quantized</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">host_transposed</span><span class="p">,</span> <span class="s1">&#39;i8&#39;</span><span class="p">)</span>
<span class="n">blocks</span><span class="o">.</span><span class="n">write_sigproc</span><span class="p">(</span><span class="n">quantized</span><span class="p">)</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">get_default_pipeline</span><span class="p">()</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">shutdown_on_signals</span><span class="p">()</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">bifrost</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction to Bifrost</a></li>
<li class="toctree-l1"><a class="reference internal" href="Getting-started-guide.html">2. Getting started guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. Create a Pipeline</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#blocks-in-this-example">3.1. Blocks in this Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#code-walkthrough">3.2. Code Walkthrough</a></li>
<li class="toctree-l2"><a class="reference internal" href="#all-the-code">3.3. All the Code</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="your-first-blocks.html">4. Your first blocks</a></li>
<li class="toctree-l1"><a class="reference internal" href="views.html">5. Views</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools-intro.html">6. Monitoring Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="bfmap.html">7. Fast GPU math using bfMap</a></li>
<li class="toctree-l1"><a class="reference internal" href="How-Python-and-C---fits-together.html">8. How bifrost fits together</a></li>
<li class="toctree-l1"><a class="reference internal" href="Common-installation-and-execution-problems.html">9. Common Installation and Execution Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="bifrost.blocks.html">10. Block Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="bifrost.html">11. Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="Cpp-Development.html">12. C++ Developement</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpp_reference.html">13. C++ Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Getting-started-guide.html" title="previous chapter"><span class="section-number">2. </span>Getting started guide</a></li>
      <li>Next: <a href="your-first-blocks.html" title="next chapter"><span class="section-number">4. </span>Your first blocks</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;1980, ledatelescope.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="sources/Create-a-pipeline.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>