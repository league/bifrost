
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Python API &#8212; bifrost 0.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
    <script src="static/jquery.js"></script>
    <script src="static/underscore.js"></script>
    <script src="static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="python-api">
<h1>Python API<a class="headerlink" href="#python-api" title="Permalink to this headline">¶</a></h1>
<section id="basic-syntax">
<h2>Basic Syntax<a class="headerlink" href="#basic-syntax" title="Permalink to this headline">¶</a></h2>
<p>As described on the [[Home]] page, Bifrost is made up of blocks, rings,
and pipelines. Blocks embody <em>black box processes</em>, and rings connect
these blocks together. A network of blocks and rings is called a
pipeline. Bifrost’s Python API mirrors these concepts very closely.</p>
<section id="let-s-start-on-an-example-here-we-will-perform-an-fft-on-an-array-and-dump-the-result-to-a-text-file">
<h3>Let’s start on an example: here we will perform an FFT on an array, and dump the result to a text file.<a class="headerlink" href="#let-s-start-on-an-example-here-we-will-perform-an-fft-on-an-array-and-dump-the-result-to-a-text-file" title="Permalink to this headline">¶</a></h3>
<p>The following code generates a list of three blocks: a <code class="docutils literal notranslate"><span class="pre">TestingBlock</span></code>,
which takes a list of numbers during its initialization (which we give
as <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>, an <code class="docutils literal notranslate"><span class="pre">FFTBlock</span></code>, which performs a one dimensional FFT
on our input, and a <code class="docutils literal notranslate"><span class="pre">WriteAsciiBlock</span></code>, which dumps everything given to
it into a text file (which we name as <code class="docutils literal notranslate"><span class="pre">'logfile.txt'</span></code>).</p>
<p>These blocks are created into a sublist, where they are proceeded by a
subsublist of input rings, and a subsublist of output rings. The
<code class="docutils literal notranslate"><span class="pre">TestingBlock</span></code> gets an output ring which we arbitrarily name
<code class="docutils literal notranslate"><span class="pre">'my</span> <span class="pre">array</span> <span class="pre">ring'</span></code>, the <code class="docutils literal notranslate"><span class="pre">FFTBlock</span></code> gets the same ring for an input
ring, and puts its results into an output ring which we name
<code class="docutils literal notranslate"><span class="pre">'fft</span> <span class="pre">output</span> <span class="pre">ring'</span></code> and <code class="docutils literal notranslate"><span class="pre">WriteAsciiBlock</span></code> gets an input ring of the
same name.</p>
<p>This list of blocks, inputs, and outputs, is fed into a <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>
object. Calling <code class="docutils literal notranslate"><span class="pre">my_pipeline.main()</span></code> then initiates the pipeline.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bifrost.block</span> <span class="kn">import</span> <span class="n">TestingBlock</span><span class="p">,</span> <span class="n">FFTBlock</span><span class="p">,</span> <span class="n">WriteAsciiBlock</span><span class="p">,</span> <span class="n">Pipeline</span>

<span class="n">my_blocks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">my_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">TestingBlock</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="p">[],</span> <span class="p">[</span><span class="s1">&#39;my array ring&#39;</span><span class="p">]])</span>
<span class="n">my_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">FFTBlock</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;my array ring&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;fft output ring&#39;</span><span class="p">]])</span>
<span class="n">my_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">WriteAsciiBlock</span><span class="p">(</span><span class="s1">&#39;logfile.txt&#39;</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;fft output ring&#39;</span><span class="p">],</span> <span class="p">[]])</span>
<span class="n">my_pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">my_blocks</span><span class="p">)</span>
<span class="n">my_pipeline</span><span class="o">.</span><span class="n">main</span><span class="p">()</span> <span class="c1">#Turn on the pipeline!</span>
</pre></div>
</div>
<p>A file named <code class="docutils literal notranslate"><span class="pre">'logfile.txt'</span></code> should now be created and filled with the
result of our FFT.</p>
<p>As you can see, creating a high-throughput Bifrost pipeline from
previously written blocks is a trivial process. This is the great thing
about Bifrost: once you have modularized your functions into blocks, you
can connect them seamlessly into a pipeline, and have your data streamed
through in real-time.</p>
</section>
</section>
<section id="blocks">
<h2>Blocks<a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Dictionaries are the form of &quot;key&quot;: &quot;value&quot; pairs. If</span>
<span class="c1"># I create a dictionary such as x={&quot;key&quot;: &quot;value&quot;},</span>
<span class="c1"># then calling x[&quot;key&quot;] produces &quot;value&quot;.</span>
<span class="c1">#I will use this key:value terminology in the</span>
<span class="c1"># following demo.</span>

<span class="c1">#Always use MultiTransformBlock. I generalized it</span>
<span class="c1"># to work for SourceBlock and SinkBlocks as well,</span>
<span class="c1"># but have yet to rename it to be &quot;Block.&quot;</span>
<span class="k">class</span> <span class="nc">DStackBlock</span><span class="p">(</span><span class="n">MultiTransformBlock</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Block which performs numpy&#39;s dstack operation on rings&quot;&quot;&quot;</span>

    <span class="c1">#This section of code defines the INTERNAL ring names. These</span>
    <span class="c1"># are internal to the block. Whenever you create an</span>
    <span class="c1"># instance of this block, it will use these ring names</span>
    <span class="c1"># inside of it to organize itself, regardless of the pipeline.</span>
    <span class="n">ring_names</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;in_1&#39;</span><span class="p">:</span> <span class="s2">&quot;Ring containing the arrays which are stacked first&quot;</span><span class="p">,</span>
        <span class="s1">&#39;in_2&#39;</span><span class="p">:</span> <span class="s2">&quot;Ring containing the arrays which are stacked second&quot;</span><span class="p">,</span>
        <span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="s2">&quot;Outgoing ring containing the stacked array&quot;</span><span class="p">}</span>

    <span class="c1">#This dictionary has keys as the ring names. Note that</span>
    <span class="c1"># input rings are prefixed as &quot;in&quot;, and output</span>
    <span class="c1"># prefixed by &quot;out&quot;, for the pipeline to help</span>
    <span class="c1"># you debug misplaced rings.</span>
    <span class="c1">#The values are descriptions---these are arbitrary and</span>
    <span class="c1"># can be empty strings if you wish. Future pipelines</span>
    <span class="c1"># may use those descriptions in dot diagrams or documentation</span>
    <span class="c1"># generation.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#This is called when you first initialize the</span>
        <span class="c1"># block before putting it your pipeline. Use</span>
        <span class="c1"># the initialization to save any user-defined</span>
        <span class="c1"># parameters which will affect the algorithm.</span>

        <span class="c1">#Call this to allow the MultiTransformBlock&#39;s</span>
        <span class="c1"># initialization to take place, which activates</span>
        <span class="c1"># some necessary functions.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DStackBlock</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">load_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#This function gets automatically called (whether</span>
        <span class="c1"># you choose to define it or not) by</span>
        <span class="c1"># MultiTransformBlock. It is called after reading</span>
        <span class="c1"># in the input ring headers, and before setting</span>
        <span class="c1"># the gulp_sizes. Use it to calculate these sizes.</span>
        <span class="c1"># This function is also called before setting</span>
        <span class="c1"># the output ring&#39;s header. Use it to calculate</span>
        <span class="c1"># the output header, and assign it to self.header[&#39;ring&#39;].</span>
        <span class="c1">#Note that this function will be called again</span>
        <span class="c1"># each time a new sequence of the ring is loaded.</span>

        <span class="c1">#Here is a safety check on the defined shape and</span>
        <span class="c1"># datatype of the incoming data. It makes</span>
        <span class="c1"># sure that the algorithm will work on the rings</span>
        <span class="c1"># in question.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_2&#39;</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">][</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_2&#39;</span><span class="p">][</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>

        <span class="c1">#Here I (initially) set the output header to be</span>
        <span class="c1"># identical to the first input header. This is</span>
        <span class="c1"># to get the data type and blanket-copy any other</span>
        <span class="c1"># parameters that may be important to algorithms</span>
        <span class="c1"># down-the-pipe.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">])</span>

        <span class="c1">#Here I calculate the require input gulp_sizes</span>
        <span class="c1"># in order to capture one &#39;shape&#39; per gulp.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gulp_size</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">][</span><span class="s1">&#39;nbit&#39;</span><span class="p">]</span><span class="o">//</span><span class="mi">8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gulp_size</span><span class="p">[</span><span class="s1">&#39;in_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gulp_size</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">]</span>

        <span class="c1">#Here I calculate the output shape. This is</span>
        <span class="c1"># a dstack command, so I am adding an extra</span>
        <span class="c1"># dimension to my data. This dimension is</span>
        <span class="c1"># 2 in length, as we have 2 input arrays.</span>
        <span class="n">outgoing_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span>
        <span class="n">outgoing_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1">#Now I put this outgoing shape into the output</span>
        <span class="c1"># ring, and calculate the gulp_size needed</span>
        <span class="c1"># to output this much data per gulp.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outgoing_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gulp_size</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gulp_size</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#This function is called once by the pipeline</span>
        <span class="c1"># once all of the rings are in place. It actually</span>
        <span class="c1"># gets called BEFORE load_settings, but</span>
        <span class="c1"># the first time you open your input rings, that</span>
        <span class="c1"># function gets called.</span>
        <span class="c1">#Define your algorithm with this function.</span>

        <span class="c1">#Here I do a blanket-read/write for loop. This</span>
        <span class="c1"># is necessary if you want to do your reading</span>
        <span class="c1"># and writing in synchrony. The self.read command</span>
        <span class="c1"># takes the names of the input rings, and</span>
        <span class="c1"># generates input_spans each loop. The self.write</span>
        <span class="c1"># command does the same for output rings. The</span>
        <span class="c1"># self.izip command turns this statement into</span>
        <span class="c1"># a single generator, so you only need one for loop.</span>
        <span class="c1">#Make sure to order your input spans and output spans</span>
        <span class="c1"># according to how they are placed in the read and</span>
        <span class="c1"># write calls.</span>
        <span class="k">for</span> <span class="n">inspan1</span><span class="p">,</span> <span class="n">inspan2</span><span class="p">,</span> <span class="n">outspan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;in_1&#39;</span><span class="p">,</span> <span class="s1">&#39;in_2&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">)):</span>
            <span class="c1">#Inside this loop, I have my input data</span>
            <span class="c1"># in the form of inspan1, and inspan2.</span>
            <span class="c1"># The output data allocation is in outspan.</span>
            <span class="c1">#All of the datatypes are loaded automatically</span>
            <span class="c1"># based on the header. All I do now is process the</span>
            <span class="c1"># input spans, and copy them into the output span.</span>
            <span class="n">outspan</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span>
                    <span class="n">inspan1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_1&#39;</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]),</span>
                    <span class="n">inspan2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;in_2&#39;</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">])))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[:]</span>
            <span class="c1">#The use of the indices [:] here is very important. It</span>
            <span class="c1"># is a copy command. Stating outspan=... would</span>
            <span class="c1"># reassign the name &quot;outspan&quot; instead of copying</span>
            <span class="c1"># data, so the output ring would receive nothing.</span>
</pre></div>
</div>
</section>
<section id="pipelines">
<h2>Pipelines<a class="headerlink" href="#pipelines" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Dummy function to generate data</span>
<span class="k">def</span> <span class="nf">generate_ten_arrays</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="c1">#Function to print numpy arrays</span>
<span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">array</span>

<span class="c1">#The following list will contain all</span>
<span class="c1"># of the initialized blocks, along</span>
<span class="c1"># with their &#39;connections&#39;, which</span>
<span class="c1"># define how blocks connect to eachother</span>
<span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1">#Each block is defined as a two-element</span>
<span class="c1"># sublist (a list within the list of blocks).</span>
<span class="c1"># The first part of the list is</span>
<span class="c1"># an object---like the one I created above.</span>
<span class="c1"># When you create the object, you call the</span>
<span class="c1"># __init__ function, so define any algorithm</span>
<span class="c1"># parameters in that part.</span>
<span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
    <span class="n">NumpySourceBlock</span><span class="p">(</span><span class="n">generate_ten_arrays</span><span class="p">()),</span>
    <span class="p">{</span><span class="s1">&#39;out_1&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}])</span>
<span class="c1">#The second part of this sublist is a dictionary</span>
<span class="c1"># of connections. &#39;out_1&#39;---the key, refers</span>
<span class="c1"># to the internal ring definition in</span>
<span class="c1"># the block. This would be one of the ring_name&#39;s</span>
<span class="c1"># that I defined above for DStackBlock.</span>
<span class="c1"># It gets used internally for organizing</span>
<span class="c1"># the headers, gulp_sizes, and so on.</span>
<span class="c1">#The 0 is the value. It is the EXTERNAL (!)</span>
<span class="c1"># ring name. It is what we want to call the</span>
<span class="c1"># ring in the context of this pipeline.</span>
<span class="c1"># If you are confused because it is a number,</span>
<span class="c1"># note that you could also use a string in</span>
<span class="c1"># place of the 0. For example &#39;raw_input&#39;</span>
<span class="c1"># is a valid name. You could define</span>
<span class="c1"># your own Ring() object, and use that in place.</span>
<span class="c1"># So long as you are consistent. Each ring</span>
<span class="c1"># should only be named once as an output, and</span>
<span class="c1"># as many times as you want as an input. Bifrost</span>
<span class="c1"># will let you know if you have used a ring</span>
<span class="c1"># twice as an output.</span>


<span class="c1">#Here I generate an identical block to feed</span>
<span class="c1"># another ring. Note that the INTERNAL name</span>
<span class="c1"># of the ring is the same as above, as it</span>
<span class="c1"># is only a marker for the block,</span>
<span class="c1"># but the EXTERNAL name of the ring, the name</span>
<span class="c1"># that our pipeline will use, is different.</span>
<span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
    <span class="n">NumpySourceBlock</span><span class="p">(</span><span class="n">generate_ten_arrays</span><span class="p">()),</span>
    <span class="p">{</span><span class="s1">&#39;out_1&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}])</span>
<span class="c1">#Here I defined the external ring to be 1.</span>
<span class="c1"># We must refer to that name later on.</span>


<span class="c1">#Here we use the block we defined above</span>
<span class="c1"># to stack these inputs together. Note that</span>
<span class="c1"># the &#39;in_1&#39; and &#39;in_2&#39; keys are the same</span>
<span class="c1"># names we used in the block definition</span>
<span class="c1"># above. We have assigned these inputs to</span>
<span class="c1"># the rings 0 and 1 in our pipeline, which</span>
<span class="c1"># are being outputted by the above generators.</span>
<span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
    <span class="n">DStackBlock</span><span class="p">(),</span>
    <span class="p">{</span><span class="s1">&#39;in_1&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;in_2&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}])</span>
<span class="c1">#For the output, we define the external</span>
<span class="c1"># ring to be 2. This will be used later.</span>

<span class="c1">#Finally, I want to see if the pipeline has</span>
<span class="c1"># worked, so I print all the outgoing arrays.</span>
<span class="c1"># NumpyBlock by default has inputs=1, outputs=1,</span>
<span class="c1"># so for this block to be satisfied with</span>
<span class="c1"># no output data, we set outputs=0 in the call to</span>
<span class="c1"># the block.</span>
<span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
    <span class="n">NumpyBlock</span><span class="p">(</span><span class="n">pprint</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="p">{</span><span class="s1">&#39;in_1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}])</span>
<span class="c1">#NumpyBlock and NumpySourceBlock have</span>
<span class="c1"># their INTERNAL rings automatically</span>
<span class="c1"># defined as</span>
<span class="c1"># in_1, in_2, ... and out_1, out_2...,</span>
<span class="c1"># for as many as you wish to make.</span>
<span class="c1">#Here we set the only input to be</span>
<span class="c1"># 2 --- the ring that is outputted</span>
<span class="c1"># by the DStackBlock.</span>

<span class="c1">#Create a pipeline with these blocks, and</span>
<span class="c1"># execute it (main).</span>
<span class="n">Pipeline</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">bifrost</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction to Bifrost</a></li>
<li class="toctree-l1"><a class="reference internal" href="Getting-started-guide.html">2. Getting started guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Create-a-pipeline.html">3. Create a Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="your-first-blocks.html">4. Your first blocks</a></li>
<li class="toctree-l1"><a class="reference internal" href="views.html">5. Views</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools-intro.html">6. Monitoring Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="bfmap.html">7. Fast GPU math using bfMap</a></li>
<li class="toctree-l1"><a class="reference internal" href="How-Python-and-C---fits-together.html">8. How bifrost fits together</a></li>
<li class="toctree-l1"><a class="reference internal" href="Common-installation-and-execution-problems.html">9. Common Installation and Execution Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="bifrost.blocks.html">10. Block Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="bifrost.html">11. Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="Cpp-Development.html">12. C++ Developement</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpp_reference.html">13. C++ Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;1980, ledatelescope.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="sources/Python-API.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>